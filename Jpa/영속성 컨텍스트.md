# 영속성 컨텍스트 (Persistent Context)  

영속성 컨텍스트는 논리적인 개념으로 **엔티티를 영구 저장하는 환경**이라는 뜻을 가지고 있다.  

엔티티 매니저를 통해 엔티티를 저장/조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.  

```java
entityManager.persist(member);
```

위 코드는 단순히 회원 엔티티를 저장한 것이 아니라 **엔티티 매니저를 사용해 회원 엔티티를 영속성 컨텍스트에 저장**한 것이다.  

## 영속성 컨텍스트의 특징  

영속성 컨텍스트는 엔티티를 식별자 값으로 구분하기 때문에 **영속 상태의 엔티티는 반드시 식별자 값이 있어야 한다.**  

JPA는 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다. 이를 **플러시(Flush)** 라고 한다.  

## 영속성 컨텍스트의 장점  

1. 1차 캐시
2. 동일성 보장
3. 트랜잭션을 지원하는 쓰기 지연
4. 변경 감지
5. 지연 로딩

### - 1차 캐시

영속성 컨텍스트 내부에는 캐시가 있는데 이를 1차 캐시라 하며 영속 상태의 엔티티는 모두 1차 캐시에 저장된다.  

쉽게 말해 **영속성 컨텍스트에 Map이 하나 있고 키는 `@Id`로 매핑한 식별자 값이고 값은 엔티티 인스턴스** 이다.  

```java
Member memberA = new Member(1L, "memberA");
entityManager.persist(memberA);
```

위 코드를 실행했을 때 1차 캐시에 회원 엔티티를 저장했지만 아직 데이터베이스에는 저장되지 않은 상태이다.  

1차 캐시의 키는 식별자 값이고 식별자 값은 데이터베이스 기본키와 매핑되어 있다.  

따라서 **영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값**이다.  

```java
Member memberA = entityManager.find(Member.class, 1L);
```

`entityManager.find()`를 호출하면 먼저 1차 캐시에서 엔티티를 찾는다.  

1차 캐시에 있는 엔티티를 조회하면 데이터베이스를 조회하지 않고 바로 불러오니 성능상 이점이 있다.  

만약 찾는 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회해 엔티티를 생성한 후 1차 캐시에 저장한 다음 영속 상태의 엔티티를 반환한다.  

```java
Member memberA = entityManager.find(Member.class, 1L);
Member memberB = entityManager.find(Member.class, 1L);

// memberA == memberB true
```

`entityManager.find(Member.class, 1L)`를 반복해서 호출해도 같은 엔티티 인스턴스를 반환한다.  

**영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.**  

### - 트랜잭션을 지원하는 쓰기지연  

엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않는다.  

내부 쿼리 저장소에 `INSERT SQL`을 쌓아두고 트랜잭션을 커밋할 때 쌓아둔 쿼리를 한번에 데이터베이스에 보내는데 이를 **트랜잭션을 지원하는 쓰기 지연**이라고 한다.  

트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시(flush)한다.  

```text
# 플러시(flush)
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업
```

플러시(flush)한 후에 실제 데이터베이스 트랜잭션을 커밋한다.  

### - 변경 감지  

`JPA`를 사용해 엔티티를 변경할 때는 단순히 엔티티를 조회한 다음 데이터만 변경해주면 된다.  

엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 **변경 감지(Dirty checking)** 이라고 한다.  

`JPA`는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해 저장해 둔다. 이를 **스냅샷**이라고 한다.  

플러시 시점에 스냅샷과 엔티티를 비교해 변경된 엔티티를 찾고, 변경된 엔티티가 있으면 수정 쿼리를 생성하 쓰기 지연 저장소에 보낸다.  

그리고 쓰기 지연 저장소에 있는 수정 쿼리를 데이터베이스에 보낸 후 데이터베이스 트랜잭션을 커밋한다.  

```text
변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
```

`JPA`의 기본 수정 전략은 엔티티의 모든 필드를 업데이트 하는 것이다.  

전송량이 증가하지만 아래와 같은 장점으로 모든 필드를 업데이트한다.  

- 모든 필드를 사용하면 수정 쿼리가 항상 같다. 
- 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다.
- 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.

---

#### 📌 Reference  

- 자바 ORM 표준 JPA 프로그래밍 | 김영한 저