# 전통적인 for 문보다는 for-each 문을 사용하라  

다음은 전통적인 for 문을 통해 배열을 순회하는 방법이다.  

```java
for (int i = 0; i < arr.length; i++) {
    // arr[i]로 어떠한 작업을 한다.
}
```

전통적인 for 문의 관용구들은 while 문보다는 나은 방법이지만 가장 좋은 방법은 아니다.  

반복자와 인덱스 변수는 코드를 지저분하게 할 뿐 개발자에게 필요한 것은 **원소**들이다.  

이처럼 쓰이는 요소 종류가 늘어나면 오류가 생갈 가능성이 높아지고, 변수를 잘못 사용할 틈새가 넓어진다. 잘못된 변수를 사용하더라도 컴파일러가 잡아준다는 보장도 없다.  

또한 컬렉션이냐, 배열이냐에 따라 코드 형태가 달라질수 있기 때문에 주의해야 한다.  

```java
for (int i = 0; i < arr.length; i++) {
    // arr[i]
}

for (int i = 0; i < list.size(); i++) {
    // list.get(i)
}
```

위에서 발생하는 문제는 **for-each** 문을 사용하면 모두 해결된다.  

> for-each 문의 정식 이름은 '향상된 for 문'(enhanced for statement) 이다.

for-each 문은 반복자와 인덱스 변수를 사용하지 않기 때문에 코드가 깔끔하고 오류가 날 일도 적다.  

하나의 관용구를 통해 컬렉션과 배열을 모두 처리할 수 있어서 컬렉션을 다루는지 배열을 다루는지 신경쓰지 않아도 된다.  

```java
for (Element element : elements) {
    // element
}
```

**콜론(:)은 안의(in)** 라고 읽으면 된다. 위 코드는 **elements 안의 각 원소 element에 대해**라고 읽는다.  

반복 대상이 배열이든 컬렉션이든 for-each 문을 사용해도 속도는 그대로이다.  

전통적인 for 문을 사용하든 for-each 문을 사용하든 속도의 차이는 없다. for-each 문이 만들어내는 코드는 사람이 손으로 최적화한 것과 사실상 같이 때문이다.  

## for-each 문을 사용할 수 없는 세 가지 상황  

#### 1. 파괴적인 필터링 (destructive filtering)  

컬렉션을 순회하면서 선택된 원소를 제거해야하는 경우 반복자의 remove 메소드를 호출해야 한다.  

자바 8부터는 Collection의 removeIf 메소드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.  

#### 2. 변형 (transforming)  

리스트나 배열을 순회하면서 해당 원소의 값 일부 혹은 전체를 교체해야 한다면 반복자의 배열의 인덱스를 사용해야 한다.  

#### 3. 병렬 반복 (parallel iteration)  

여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.  


전통적인 for 문과 비교했을 때 for-each 문은 명료하고, 유연하고, 버그를 예방해주고, 성능 저하도 없다. 되도록이면 for 문보다는 for-each 문을 사용하는 것이 좋다.  

---

#### 📌 Reference  

- Effective Java 3/E | Joshua Bloch