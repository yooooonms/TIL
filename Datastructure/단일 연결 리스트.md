# 단일 연결 리스트(Linked List)  

<img src="/Datastructure/image/list-01.png" width="750" height="100">  

연결 리스트는 노드라는 데이터로 이루어진 선형 자료구조이다.  

노드는 **데이터와 링크** 쌍으로 이루어져 있으며 링크를 통해 자신의 다음 노드와 연결되어 있다.  

#### - 제일 앞에 노드 삽입  

<img src="/Datastructure/image/list-02.png" width="750" height="200">  

새로운 노드의 링크를 헤드의 다음 노드를 가리키게 한다.  

헤드가 새로운 노드를 가리키게 한다.  

```java
private void linkFirst(E item) {
    Node<E> newNode = new Node<>(item);
    if (head == null) {
        head = newNode;
        return;
    }
    newNode.next = head;
    head = newNode;
    size++;
}
```

#### - 제일 마지막에 노드 삽입  

<img src="/Datastructure/image/list-04.png" width="750" height="250">  

가장 마지막에 있는 노드를 얻어오고 마지막 노드가 새로운 노드를 가리키게 한다.  

```java
private void linkLast(E item) {
    Node<E> newNode = new Node<>(item);
    if (head == null) {
        head = newNode;
    } else {
        Node<E> prev = node(size - 1);
        prev.next = newNode;
    }
    size++;
}
```

#### - 중간에 노드 삽입  

<img src="/Datastructure/image/list-03.png" width="750" height="250">  

삽입하려는 위치의 `이전 노드(prev)`를 얻어온다.  

`새로운 노드(newNode)`는 `이전 노드(prev)`가 가리키고 있던 `다음 노드(next)`를 가리키게 하고  

`이전 노드(prev)`는 `새로운 노드(newNode)`를 가리키게 한다.  

```java
private void linkBefore(E item, Node<E> prev) {
    Node<E> newNode = new Node<>(item);
    newNode.next = prev.next;
    prev.next = newNode;
    size++;
}
```

#### - 중간에 있는 노드 삭제  

<img src="/Datastructure/image/list-05.png" width="750" height="200">  

삭제하려는 이전 노드의 정보(prev)를 얻어온다.  

`prev`의 다음 노드는 `삭제 노드(remove)`의 `다음 노드(next)`를 가리키게 만든다.  

```java
private void unlink(Node<E> prev) {
    Node<E> remove = prev.next;
    prev.next = remove.next;
    remove = null;
    size--;
}
```

#### - 제일 앞에 노드 삭제  

<img src="/Datastructure/image/list-07.png" width="750" height="200">  

```java
private void unlinkFirst() {
    Node<E> node = head;
    head = head.next;
    node.item = null;
    node.next = null;
    size--;
}
```

#### - 제일 뒤에 노드 삭제  

<img src="/Datastructure/image/list-06.png" width="750" height="100">  

가장 마지막에 있는 노드의 이전 노드(prev)를 구해온 다음 이전 노드(prev)는 `null`을 가리키게 한다. 

```java
private void unlinkLast() {
    Node<E> prev = node(size - 2);
    prev.next = null;
    size--;
}
```

#### - 특정 위치의 노드 구하기  

단일 연결 리스트는 `HEAD` 노드를 통해서만 접근할 수 있기 때문에  

특정 위치에 있는 노드에 접근하려면 가장 앞에 있는 노드부터 순차적으로 탐색해야 한다.  

```java
private Node<E> node(int index) {
    Node<E> node = head;
    for (int i = 0; i < index; i++) {
        node = node.next;
    }
    return node;
}
```

## 전체 코드  

```java
public class LinkedList<E> {

    private static class Node<E> {
        E item;
        Node<E> next;

        public Node(E item) {
            this.item = item;
        }
    }

    private Node<E> head;
    private int size = 0;

    public LinkedList() {
    }

    private Node<E> node(int index) {
        Node<E> node = head;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    private void linkFirst(E item) {
        Node<E> newNode = new Node<>(item);
        if (head == null) {
            head = newNode;
            return;
        }
        newNode.next = head;
        head = newNode;
        size++;
    }

    private void linkLast(E item) {
        Node<E> newNode = new Node<>(item);
        if (head == null) {
            head = newNode;
        } else {
            Node<E> prev = node(size - 1);
            prev.next = newNode;
        }
        size++;
    }

    private void linkBefore(E item, Node<E> prev) {
        Node<E> newNode = new Node<>(item);
        newNode.next = prev.next;
        prev.next = newNode;
        size++;
    }

    private void unlinkFirst() {
        Node<E> node = head;
        head = head.next;
        node.item = null;
        node.next = null;
        size--;
    }

    private void unlinkLast() {
        Node<E> prev = node(size - 2);
        prev.next = null;
        size--;
    }

    private void unlink(Node<E> prev) {
        Node<E> remove = prev.next;
        prev.next = remove.next;
        remove = null;
        size--;
    }

    public void addFirst(E item) {
        linkFirst(item);
    }

    public void addLast(E item) {
        linkLast(item);
    }

    public void add(E item) {
        linkLast(item);
    }

    public void add(int index, E item) {
        checkPositionIndex(index);
        if (index == size) {
            linkLast(item);
        } else {
            linkBefore(item, node(index - 1));
        }
    }

    public void remove() {
        unlinkLast();
    }

    public void remove(int index) {
        checkElementIndex(index);
        unlink(node(index - 1));
    }

    public void removeFirst() {
        unlinkFirst();
    }

    public void removeLast() {
        unlinkLast();
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }

    private boolean isElementIndex(int index) {
        return index >= 0 && index < size;
    }

    private void checkElementIndex(int index) {
        if (!isElementIndex(index)) {
            throw new IndexOutOfBoundsException("Index: " + index +"Size: " + size);
        }
    }

    private boolean isPositionIndex(int index) {
        return index >= 0 && index <= size;
    }

    private void checkPositionIndex(int index) {
        if (!isPositionIndex(index)) {
            throw new IndexOutOfBoundsException("Index: " + index +"Size: " + size);
        }
    }

}
```