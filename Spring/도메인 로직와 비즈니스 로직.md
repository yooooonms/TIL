트랜잭션 스크립트와 도메인 모델은 **마틴 파울러**가 재창한 두 개의 개념으로 비즈니스 로직을 처리하는 두 가지 패턴을 말한다.  

책임지는 쪽이 Domain Level이냐 Script Level이냐에 따라 구분된다.  

다음은 Service Layer에서 처리되는 비즈니스 로직으로 **트랜잭션 스크립트** 패턴이라고 불리운다.  

```java
@Transactional
public Order cancelOrder(int orderId) {
	
    // 1)
    OrderDto order = orderDao.selectOrders(orderId);
    BiliingDto billing = billingDao.selectBilling(orderId);
    DeliveryDto delivery = deliveryDao.selectDelivery(orderId);
    
    // 2)
    String deliveryStatus = delivery.getStatus();
    
    // 3)
    if("IN_PROGRESS".equals(deliveryStatus)) {
    	delivery.setStatus("CANCEL");
        deliveryDao.update(delivery);
    }
    
    // 4)
    order.setStatus("CANCEL");
    orderDao.update(order);
    
    billing.setStatus("CANCEL");
    deliveryDao.update(billing);
    
    return order;
}
```

트랜잭션 스크립트 패턴은 Service Layer에서 모든 비즈니스 로직을 처리하기 때문에 구현이 쉽고 매우 간단하다. 객체는 단순히 데이터 덩어리를 하는 것이다.  

하지만 구조가 복잡해 질수록 모듈화의 복잡도가 높아지고, 쉬운 개발에 익숙해져 공통된 코드를 모듈로 분리하지 않고 copy & paste 방식으로 중복된 코드를 만드는 유혹에 빠지기 쉽다.  

```java
@Transactional
public Order cancelOrder(int orderId) {
	
    // 1)
    Orders order = ordersRepository.findById(orderId);
    Billing billing = billingRepository.findByOrderId(orderId);
    Delivery delivery = deliveryRepository.findByOrderId(orderId);
    
    // 2-3)
    delivery.cancel();
    
    // 4)
    order.cancel();
    billing.cancel();
    
    return order;
}
```

트랜잭션 스크립트 패턴과 반대로 Domain에서 비즈니스 로직을 처리하는 방식을 **도메인 모델** 패턴이라고 한다.  

객체가 수행해야하는 업무를 분담시킴으로써 Service Layer에서는 트랜잭션과 도메인의 순서를 보장하는 역할만 제공하고 비즈니스 로직은 Domain에서 처리한다.  

객체 지향에 기반한 재사용성, 확장성 그리고 유지 보수의 편리함이 있지만 하나의 도메인 모델을 구축하는데 많은 노력이 필요하다.  

**객체를 판별하고 객체들 간의 관계를 정립, 데이터베이스 사이의 매핑에 대해 고민해야 하는 노력이 필요하다.**  

따라서 도메인 모델에 능숙한 개발자가 없을 경우 구축 자체가 힘들어 질 수 있다.  

---

#### 📌 Reference  

- <https://javacan.tistory.com/entry/94>
- <https://velog.io/@ovan/Domain-Layer에서-비즈니스-로직-처리하기>